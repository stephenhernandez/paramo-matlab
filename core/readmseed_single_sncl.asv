function [S_,successFlag,gapFlag] = readmseed_single_sncl(ntwk,stnm,locid,chan,...
    startTimesOrig,encodingFormat,raw,isBigEndian,verboseFlag,dataRecordLength,...
    dataBeginOffset,nSamplesBeforeDecompression,sampleRateOrig,interpFlag)
%
%
%

%%
S_ = populateWaveforms();
gapFlag = false;
successFlag = false;

%%
startCol = dataBeginOffset+1;
encodedSignalMatrix = raw(startCol:end,:);
sampleRateOrig = abs(sampleRateOrig); % HACK: take abs() because sometimes a negative is returned
if any(diff(sampleRateOrig))
    if verboseFlag
        fprintf(2,'not all samplerate chunks are the same\n');
    end
    return;
end

%%
origSampleRate = double(sampleRateOrig(1));
if ~origSampleRate %if sample rate is == 0...
    if verboseFlag
        fprintf('using derived rate (temporarily)\n');
    end
    origSampleRate = median(1./((diff(startTimesOrig)*86400)./nSamplesBeforeDecompression(1:end-1)));
end

% get the signal
successFlag = true;
firstTime = startTimesOrig(1);
[trace,gapInfo,gapFlag,nOverlaps] = decodeMiniSeedSignal(startTimesOrig,...       % typical file: 0.5 seconds
    encodedSignalMatrix,encodingFormat,isBigEndian,dataRecordLength,...
    origSampleRate,dataBeginOffset,interpFlag);

if isempty(trace)
    if verboseFlag
        fprintf(2,"empty trace!\n");
    end
    gapFlag = false;
    successFlag = false;
    return;
end

%%
[minVals,maxVals,meanVals] = minmaxmean(trace);
delta = 1/origSampleRate;
npts = size(trace,1);
firstTime = dn2dt(firstTime);
S_.('kstnm') = stnm;
S_.('ref') = firstTime;
S_.('kcmpnm') = chan;
S_.('knetwk') = ntwk;
S_.('khole') = locid;
S_.('delta') = delta;
S_.('d') = double(trace);
S_.('b') = seconds(0);
S_.('npts') = npts;
S_.('e') = seconds((npts - 1)*delta); % assumes b = 0
S_.('gapFlag') = gapFlag;
S_.('gapInfo') = gapInfo;
S_.('depmin') = minVals;
S_.('depmax') = maxVals;
S_.('depmen') = meanVals;

%%
if verboseFlag
    sizeE = size(encodedSignalMatrix);
    fprintf("sncl: %s.%s.%s.%s; first time: %s; gapFlag: %d; nOverlaps: %d; nrows: %d; ncols: %d; nGaps: %d\n",...
        ntwk,firstTime,gapFlag,nOverlaps,sizeE(1),sizeE(2),size(gapInfo,1));
end