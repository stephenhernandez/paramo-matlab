clear; close all;
startup(true);
strong_motion_dir = fullfile("~","masa","strong_motion");
cd(strong_motion_dir);

% readFile = 'summary_VEL.txt'; %'summary_DISP.txt'; %'summary_VEL.txt'; %'summary_ACC.txt';
% toProcess = 'AmplitudeVsDistance_VEL.png'; %'AmplitudeVsDistance_DISP.png'; %'AmplitudeVsDistance_VEL.png'; %'AmplitudeVsDistance_ACC.png'; %'AmplitudeVsDistance_WA.png'
% removeVar = "MedianVel"; %"MedianAcc";

readFile = 'summary_ACC.txt';
toProcess = 'AmplitudeVsDistance_ACC.png'; %'AmplitudeVsDistance_WA.png'
removeVar = "MedianAcc";
unitsStr = '$cm \cdot s^{-2}$';

% readFile = 'summary_DISP.txt';
% toProcess = 'AmplitudeVsDistance_DISP.png'; %'AmplitudeVsDistance_WA.png'
% removeVar = "MedianDisp";
% unitsStr = '$cm$';

%VariableNames = {'NET_STATION_LOCID_CMPNM','MaxWADisp','MedianWADisp','TimeOfMaxDisp','DIST','AZ','BAZ','PeakVecDisp','EstimatedDuration'};
VariableNames = {'NET_STATION_LOCID_CMPNM',...
    'MaxAcc',...
    'TimeOfMaxAcc',...
    'DIST',...
    'AZ','BAZ','PeakVecACC','EstimatedDuration_'};

yearList = dir('20*');
lYears = length(yearList);
eventListMain = [];
for i = 1:lYears
    thisYear = yearList(i).name;
    cd(thisYear);
    monthList = dir();
    delI = startsWith({monthList.name},'.');
    monthList(delI) = [];
    lMonths = length(monthList);
    for j = 1:lMonths
        thisMonth = monthList(j).name;
        cd(thisMonth);
        eventList = dir();
        delI = startsWith({eventList.name},'.');
        eventList(delI) = [];
        lEvents = length(eventList);
        for k = 1:lEvents
            thisEvent = eventList(k).name;
            cd(thisEvent);
            pngs = dir('*.png');
            lia = ismember(toProcess,pull(pngs,'name',""));
            if ~lia
                cd ..;
                continue;
            end
            eventid = split(thisEvent,'_');
            eventid = string(eventid(1));
            eventListMain = [eventListMain; eventid];
            cd ..
        end
        cd ..;
    end
    cd ..;
end

%%
lID = length(eventListMain);
E = populateSeisCompStructure(lID);
n = 0;
for i = 1:lID
    disp(i);
    event_ = eventListMain(i);
    try
        n = n+1;
        E(n) = readSCBulletin(event_);
    catch
        n = n-1;
        continue;
    end
end
E = E(1:n);
clear n;

%%
stderr = pull(E,'rms');
nPhases = pull(E,'usedPhases');
nMag = pull(E,'nmag');
nSphases = pull(E,'nSphases');
magerr2 = pull(E,'magerr2');
timerr = pull(E,'timerr');
laterr = pull(E,'laterr');
lonerr = pull(E,'lonerr');
deptherr = pull(E,'deptherr');
magerr1 = pull(E,'magerr');
t = pull(E,'t');
mag = pull(E,'mag');
azgap = pull(E,'azgap');
depth = pull(E,'depth');
lon = pull(E,'lon');
lat = pull(E,'lat');
evType = pull(E,'evType');
totErr = sqrt(laterr.^2 + lonerr.^2 + deptherr.^2);
methodID = pull(E,'methodID');
errorDepthRatio = totErr./abs(depth);

%%
allIDs = pull(E,'id');
minT = datetime(2000,01,01);
maxT = datetime(2026,01,01);
minNmlv = 6;
azGapThresh = 270;
minMag = 4;
maxMag = 8;
minPhases = 10;
timeErrThresh = 1.5;
rmsThresh = timeErrThresh;
spatialErrThresh = 20;
errorDepthRatioThresh = 2;
magerrThresh1 = 0.4;
magerrThresh2 = 0.4;
minDeptherr = -0.2;
minDepth = -10;
maxDepth = 750;
minSphases = 4;
minTimeErr = 0;

%%
tI = t >= minT & t <= maxT & nMag >= minNmlv & ...
    nPhases >= minPhases & mag <= maxMag & mag >= minMag & azgap <= azGapThresh & ...
    abs(magerr1) <= magerrThresh1 & abs(magerr2) <= magerrThresh2 & ...
    timerr >= minTimeErr & timerr <= timeErrThresh & stderr <= rmsThresh & ...
    depth > minDepth & depth <= maxDepth & deptherr > minDeptherr & ...
    (totErr < spatialErrThresh | errorDepthRatio <= errorDepthRatioThresh) & ...
    nSphases >= minSphases & ~(evType == "outsideofnetworkinterest");
sum(tI)

%%
IDfiltered = allIDs(tI);
lIDs = length(IDfiltered);
tF = t(tI);
magF = mag(tI);
depthF = depth(tI);
latF = lat(tI);
lonF = lon(tI);
Efiltered = E(tI);

%sensorTypeList = ["HN"]; %["HN";"EN";"BL";"BH";"HH"]; %["BH";"HN";"HH";"HN";"EN";"BL"];
sensorTypeList = ["BH";"HH";"HN";"EN";"BL"];
%sensorTypeList = ["BH";"HH"];
%sensorTypeList = ["HN";"EN";"BL"];
minDur = 0; %0.0010; %2;
maxDur = 1800; %seconds
maxAmpAcc = 1e3; %12e4;
maxAmpSeis = 3e1; %2e1; %2; %2e1; %2 for VEL/DISP, and 20 for ACC
minAmp = 1e-2; %4e-3 for VEL/DISP, and 1e-2 for ACC
MinStations = 4;
maxDist = 1e3; %8e2;
MinComponents = 3;
magFact = 3;

%%
cd(strong_motion_dir);
rMain = [];
azMain = [];
bazMain = [];
peakVecMain = [];
durationMain = [];
idMain = [];
tMain = [];
magMain = [];
snclMain = [];
maxCmpAmpMain = [];
medAmpMain = [];
depthMain = [];
latMain = [];
lonMain = [];

for i = 1:lYears
    thisYear = yearList(i).name;
    cd(thisYear);
    monthList = dir();
    delI = startsWith({monthList.name},'.');
    monthList(delI) = [];
    lMonths = length(monthList);

    %
    for j = 1:lMonths
        thisMonth = monthList(j).name;
        cd(thisMonth);
        eventList = dir();
        delI = startsWith({eventList.name},'.');
        eventList(delI) = [];
        lEvents = length(eventList);

        %
        for k = 1:lEvents
            thisEvent = eventList(k).name;
            cd(thisEvent);
            pngs = dir('*.png');
            lia = ismember(toProcess,pull(pngs,'name',""));
            if ~lia
                cd ..;
                continue;
            end
            eventid = split(thisEvent,'_');
            t_ = datetime(string(eventid(end)));
            eventid = string(eventid(1));
            [lia,locb] = ismember(eventid,IDfiltered);
            if ~lia
                cd ..;
                continue;
            end

            %
            disp([t_ tF(locb(lia))]);
            T = readtable(readFile);
            if size(T,2) > 8
                T = removevars(T,removeVar);
            end
            T.Properties.VariableNames = VariableNames;
            NET_STATION_LOCID_CMPNM = string(T.NET_STATION_LOCID_CMPNM);
            NET_STATION_LOCID = NET_STATION_LOCID_CMPNM;
            sensorType = NET_STATION_LOCID_CMPNM;
            for ii = 1:length(NET_STATION_LOCID_CMPNM)
                NET_STATION_LOCID_ = NET_STATION_LOCID_CMPNM(ii);
                sensorType_ = split(NET_STATION_LOCID_,".");
                sensorType_ = char(sensorType_(end));
                sensorType(ii) = string(sensorType_(1:end-1));
                NET_STATION_LOCID_ = char(NET_STATION_LOCID_);
                NET_STATION_LOCID(ii) = string(NET_STATION_LOCID_(1:end-1));
            end
            cmpnmI = ismember(sensorType,sensorTypeList);
            duration_ = T.EstimatedDuration_;
            amp_ = T.PeakVecACC;
            %amp2_ = T.MedianWADisp;
            dists_ = T.DIST;
            %T
            %distsOrig = dists_;
            %dists_ = sqrt(dists_.^2 + depthF(locb(lia)).^2); %for certain files, i already converted to hypocentral distance, so runing this line would apply the correction twice which would be wrong
            %T.DIST = dists_;
            %table(T.DIST,T.PeakVecACC)
            %figure(); loglog(T.DIST,T.PeakVecACC,'.'); zoom on; grid on;
            cmpnmI = (cmpnmI & duration_ >= minDur & duration_ <= maxDur & ...
                amp_ <= maxAmpAcc & dists_ <= maxDist) & amp_ >= minAmp & ...
                ~((sensorType == "BH" | sensorType == "HH") & amp_ >= maxAmpSeis) & ...
                ~((sensorType == "BH" | sensorType == "HH") & amp_ < minAmp);
            NET_STATION_LOCID = NET_STATION_LOCID(cmpnmI);
            T = T(cmpnmI,:);

            %
            uniqueMonitoringSensors = unique(NET_STATION_LOCID);
            lUniqueMonitoringSensors = length(uniqueMonitoringSensors);
            if lUniqueMonitoringSensors < MinStations
                cd ..;
                continue;
            end

            %
            n = 0;
            for ii = 1:lUniqueMonitoringSensors
                thisSNCL = uniqueMonitoringSensors(ii);
                lia2 = ismember(NET_STATION_LOCID,thisSNCL);
                nSNCLs = sum(lia2);
                if nSNCLs < MinComponents
                    fprintf('not enough channels for: %s\n',thisSNCL);
                    continue;
                end
                n = n+1;
            end

            if n < MinStations
                fprintf('not enough monitoring points for event: %s\n',eventid);
                cd ..;
                continue;
            end

            % the bulk of the work
            for ii = 1:lUniqueMonitoringSensors
                thisSNCL = uniqueMonitoringSensors(ii);
                lia3 = ismember(NET_STATION_LOCID,thisSNCL);
                nSNCLs = sum(lia3);
                if nSNCLs < MinComponents
                    fprintf('not enough channels for: %s\n',thisSNCL);
                    continue;
                end
                %T_ = T(lia3,:);
                %rMain = [rMain; median(T_.DIST)];
                %azMain = [azMain; median(T_.AZ)];
                %bazMain = [bazMain; median(T_.BAZ)];
                %peakVecMain = [peakVecMain; median(T_.PeakVecACC)];
                %durationMain = [durationMain; median(T_.EstimatedDuration_)];
                %idMain = [idMain; eventid];
                %depthMain = [depthMain; depthF(locb)];
                %latMain = [latMain; latF(locb)];
                %lonMain = [lonMain; lonF(locb)];
                %tMain = [tMain; tF(locb)];
                %magMain = [magMain; magF(locb)];
                snclMain = [snclMain; thisSNCL];
                %maxCmpAmpMain = [maxCmpAmpMain; max(T_.PeakVecACC)];
                %medAmpMain = [medAmpMain; max(T_.MedianWADisp)];
            end
            cd ..
        end
        cd ..;
    end
    cd ..;
end

%%
MinGoodStationObservations = MinStations;
goodUniqueSNCLs = unique(snclMain);
uniqSNCLcount = groupcounts(snclMain);
goodUniqueSNCLs = goodUniqueSNCLs(uniqSNCLcount >= MinGoodStationObservations);

%%
cd(strong_motion_dir);
stnmMain = [];
kcmpnmMain = [];
rMain = [];
azMain = [];
bazMain = [];
peakVecMain = [];
durationMain = [];
idMain = [];
tMain = [];
magMain = [];
snclMain = [];
maxCmpAmpMain = [];
medAmpMain = [];
depthMain = [];
latMain = [];
lonMain = [];
finalEventList = [];

%%
for i = 1:lYears
    thisYear = yearList(i).name;
    cd(thisYear);
    monthList = dir();
    delI = startsWith({monthList.name},'.');
    monthList(delI) = [];
    lMonths = length(monthList);

    %
    for j = 1:lMonths
        thisMonth = monthList(j).name;
        cd(thisMonth);
        eventList = dir();
        delI = startsWith({eventList.name},'.');
        eventList(delI) = [];
        lEvents = length(eventList);

        %
        for k = 1:lEvents
            thisEvent = eventList(k).name;
            cd(thisEvent);
            pngs = dir('*.png');
            lia = ismember(toProcess,pull(pngs,'name',""));
            if ~lia
                cd ..;
                continue;
            end
            eventid = split(thisEvent,'_');
            t_ = datetime(string(eventid(end)));
            eventid = string(eventid(1));
            [lia,locb] = ismember(eventid,IDfiltered);
            if ~lia
                cd ..;
                continue;
            end

            %
            disp([t_ tF(locb)]);
            T = readtable(readFile);
            if size(T,2) > 8
                T = removevars(T,removeVar);
            end
            T.Properties.VariableNames = VariableNames;
            dists_ = T.DIST;
            %dists_ = sqrt(dists_.^2 + depthF(locb(lia)).^2);
            %T.DIST = dists_;
            [~,sortDistI] = sort(dists_);
            T = T(sortDistI,:);
            NET_STATION_LOCID_CMPNM = string(T.NET_STATION_LOCID_CMPNM);
            NET_STATION_LOCID = NET_STATION_LOCID_CMPNM;
            sensorType = NET_STATION_LOCID_CMPNM;
            for ii = 1:length(NET_STATION_LOCID_CMPNM)
                NET_STATION_LOCID_ = NET_STATION_LOCID_CMPNM(ii);
                sensorType_ = split(NET_STATION_LOCID_,".");
                sensorType_ = char(sensorType_(end));
                sensorType(ii) = string(sensorType_(1:end-1));
                NET_STATION_LOCID_ = char(NET_STATION_LOCID_);
                NET_STATION_LOCID(ii) = string(NET_STATION_LOCID_(1:end-1));
            end
            cmpnmI = ismember(sensorType,sensorTypeList) & ...
                ismember(NET_STATION_LOCID,goodUniqueSNCLs);
            duration_ = T.EstimatedDuration_;
            amp_ = T.PeakVecACC;
            dists_ = T.DIST;
            cmpnmI = (cmpnmI & duration_ >= minDur & duration_ <= maxDur & ...
                amp_ <= maxAmpAcc & dists_ <= maxDist) & ...
                ~((sensorType == "BH" | sensorType == "HH") & amp_ >= maxAmpSeis) & ...
                ~((sensorType == "BH" | sensorType == "HH") & amp_ < minAmp) & ...
                amp_ >= minAmp;
            NET_STATION_LOCID = NET_STATION_LOCID(cmpnmI);
            T = T(cmpnmI,:);

            %
            uniqueMonitoringSensors = unique(NET_STATION_LOCID);
            lUniqueMonitoringSensors = length(uniqueMonitoringSensors);
            if lUniqueMonitoringSensors < MinStations
                cd ..;
                fprintf('skipping %s\n',eventid);
                continue;
            end

            %
            n = 0;
            for ii = 1:lUniqueMonitoringSensors
                thisSNCL = uniqueMonitoringSensors(ii);
                lia = ismember(NET_STATION_LOCID,thisSNCL);
                nSNCLs = sum(lia);
                if nSNCLs < MinComponents
                    fprintf('not enough channels for: %s\n',thisSNCL);
                    continue;
                end
                n = n+1;
            end

            if n < MinStations
                fprintf('not enough monitoring points for event: %s\n',eventid);
                cd ..;
                fprintf('skipping %s\n',eventid);
                continue;
            end

            % the bulk of the work
            for ii = 1:lUniqueMonitoringSensors
                thisSNCL = uniqueMonitoringSensors(ii);
                lia = ismember(NET_STATION_LOCID,thisSNCL);
                nSNCLs = sum(lia);
                if nSNCLs < MinComponents
                    fprintf('not enough channels for: %s\n',thisSNCL);
                    continue;
                end
                T_ = T(lia,:);
                NET_STATION_LOCID_CMPNM_ = string(T_.NET_STATION_LOCID_CMPNM);
                NET_STATION_LOCID_CMPNM_ = NET_STATION_LOCID_CMPNM_(1);
                %snclMain = [snclMain; NET_STATION_LOCID_CMPNM_];
                str_split = split(NET_STATION_LOCID_CMPNM_,'.');
                stnmMain = [stnmMain; str_split(2)];
                kcmpnmMain = [kcmpnmMain; str_split(4)];
                rMain = [rMain; median(T_.DIST)];
                azMain = [azMain; median(T_.AZ)];
                bazMain = [bazMain; median(T_.BAZ)];
                peakVecMain = [peakVecMain; median(T_.PeakVecACC)];
                durationMain = [durationMain; median(T_.EstimatedDuration_)];
                idMain = [idMain; eventid];
                depthMain = [depthMain; depthF(locb)];
                latMain = [latMain; latF(locb)];
                lonMain = [lonMain; lonF(locb)];
                tMain = [tMain; tF(locb)];
                magMain = [magMain; magF(locb)];
                snclMain = [snclMain; thisSNCL];
                maxCmpAmpMain = [maxCmpAmpMain; max(T_.PeakVecACC)];
                %medAmpMain = [medAmpMain; max(T_.MedianWADisp)];
            end
            finalEventList = [finalEventList; eventid];
            cd ..
        end
        cd ..;
    end
    cd ..;
end

%%
close all;
sensorTypeMain = char(kcmpnmMain);
sensorTypeMain = string(sensorTypeMain(:,1:2));
sensorTypes = ["acc";"sismometro"];
symb = ["o";"o"];
fig1 = figure('units','normalized','outerposition',[0.1 0.1 0.8 0.8]);
clear axAmp;
tiledlayout(1,2,"Padding","compact","TileSpacing","compact");
for i = 1:length(sensorTypes)
    axAmp(i) = nexttile();
    hold on;
    sensorType_ = sensorTypes(i);
    if strcmp(sensorType_,"acc")
        typeI = strcmp(sensorTypeMain,"HN") | ...
            strcmp(sensorTypeMain,"EN") | ...
            strcmp(sensorTypeMain,"BL");
    else
        typeI = strcmp(sensorTypeMain,"HH") | strcmp(sensorTypeMain,"BH");
    end

    SS = scatter(axAmp(i),rMain(typeI),peakVecMain(typeI),magFact*exp(magMain(typeI)),...
        depthMain(typeI),symb(i),'filled'); zoom on;
    axAmp(i).YScale = 'log';
    axAmp(i).XScale = 'log';
    %lgh = legend(sensorTypes);
    SS.MarkerEdgeColor = 'k';
    SS.MarkerEdgeAlpha = 0.2;
    SS.MarkerFaceAlpha = 0.5;
    grid on;
    cbar = colorbar;
    cbar.Label.Interpreter = 'latex';
    cbar.Label.String = 'depth [km.]';
    set(axAmp(i),"ColorScale",'log');
    clim([1 200]);
    ylim([1e-3 1e3]);
    xlim([1 1e3]);
    grid on;
    xlabel('Hypocentral Distance [km.]');
    ylabel(strcat('Peak Vector Amplitude, [',unitsStr,']'));
end
axAmp(1).Title.String = "Acelerometros";
axAmp(2).Title.String = "Sismometros";
linkaxes(axAmp,"xy");

%%
fig2 = figure('units','normalized','outerposition',[0.1 0.1 0.8 0.8]);
clear ax;
tiledlayout(1,2,"Padding","compact","TileSpacing","compact");
for i = 1:length(sensorTypes)
    ax(i) = nexttile();
    hold on;
    sensorType_ = sensorTypes(i);
    if strcmp(sensorType_,"acc")
        typeI = strcmp(sensorTypeMain,"HN") | ...
            strcmp(sensorTypeMain,"EN") | ...
            strcmp(sensorTypeMain,"BL");
    else
        typeI = strcmp(sensorTypeMain,"HH") | strcmp(sensorTypeMain,"BH");
    end
    axMap = gca;
    [stla,stlo,stel] = metaDataFromStationList(unique(stnmMain(typeI)));
    plot(stlo,stla,'v'); zoom on; grid on; axis equal;
    load ~/igdata/ec_boundaries.mat
    load ~/igdata/soam_noec.mat
    hold on; plot(lonEC,latEC,'k-','linewidth',2); axis equal;
    hold on; plot(lon_noec,lat_noec,'-','linewidth',2,'color',[0.5 0.5 0.5]); axis equal;
    text(stlo,stla,unique(stnmMain(typeI)),'FontSize',15);
    xlim([-82 -74.5]);
    ylim([-5.5 2])
    xlabel('long.'); ylabel('lat.');
    axMap.Box = 'on';
end

%%
uniqIDs = unique(idMain);
lUniqIDs = length(uniqIDs);
gCount = 1;
gFlag = true;
if gFlag
    gMax = 1e7;
    Gmain = zeros(gMax,length(goodUniqueSNCLs)+2);
    dMain = NaN(gMax,1);
end
cumG = 0;

for i = 1:lUniqIDs
    id_ = uniqIDs(i);
    uI = idMain == id_;
    nAmps = sum(uI); %eeeeeeeeeeeeequivalent to number of stations for this particular event
    sncls_ = snclMain(uI);
    %amp_ = medAmpMain(uI);
    amp_ = peakVecMain(uI);
    r_ = rMain(uI);
    [r_,sortDistI] = sort(r_);
    amp_ = amp_(sortDistI);
    sncls_ = sncls_(sortDistI);

    [~,goodSnclsI] = ismember(sncls_,goodUniqueSNCLs);
    diffCount = nAmps*(nAmps - 1)*0.5;
    if gFlag
        Gtmp = full(Gvdcc(nAmps));
        Gtmp = Gtmp(1:end-1,:);
        difflog = -getDD(log10(r_));
        difflin = -getDD(r_);
        difflogamp = getDD(log10(amp_));
        Gmain(gCount:gCount+diffCount-1,1) = difflog;
        Gmain(gCount:gCount+diffCount-1,2) = difflin;
        dMain(gCount:gCount+diffCount-1) = difflogamp;
        for j = 1:nAmps
            Gmain(gCount:gCount+diffCount-1,goodSnclsI(j)+2) = Gtmp(:,j);
        end
    end
    gCount = gCount + diffCount;
    fprintf("%d/%d %d %d\n",i,lUniqIDs,nAmps,gCount-1);
end

%%
if gFlag
    dMain = dMain(1:gCount-1);
    Gmain = Gmain(1:gCount-1,:);
end

badI = find(Gmain(:,1)==0 | Gmain(:,2)==0 | Gmain(:,2) >= 800 | dMain < -0 | ...
    dMain > 2 | Gmain(:,2).*dMain < 1 | Gmain(:,1).*dMain > 3 | ...
    Gmain(:,3).*dMain >= 6e2);
Gmain(badI,:) = [];
dMain(badI) = [];

Gmain = [Gmain; [0 0 ones(1,length(goodUniqueSNCLs))]];
dMain = [dMain; 0];
solution = Gmain\dMain;

rdum = logspace(log10(1),log10(maxDist),601);
att1 = solution(1)*log10(rdum) + solution(2)*rdum;  %hernandez
att2 = 1.11*log10(rdum) + 0.00189*rdum + 0.591;     %uhrhammer

figure('units','normalized','outerposition',[0 0 1 1]);
semilogx(rdum,att1,'.'); zoom on; grid on; hold on;
semilogx(rdum,att2,'.');
ylim([0 6]);
gamma17 = -interp1(rdum,att1,17) + 2;
gamma100 = -interp1(rdum,att1,100) + 3;
attGamma17 = att1 + gamma17;
hold on;
semilogx(rdum,attGamma17,'.','color',[0.5 0.5 0.5]); grid on;
attGamma100 = att1 + gamma100;
hold on;
semilogx(rdum,attGamma100,'.','color',[0.3 0.3 0.3]); grid on;
legend('new','uhrhammer','fix17','fix100','location','northwest');

%%
Efinal = populateSeisCompStructure(length(finalEventList));
for i = 1:length(finalEventList)
    Efinal(i) = readSCBulletin(finalEventList(i));
end

figure(); S3 = scatter(pull(Efinal,'lon'),pull(Efinal,'lat'),...
    magFact*exp(pull(Efinal,'mag')),pull(Efinal,'depth'),'o','filled'); zoom on; grid on; axis equal;
load ~/igdata/ec_boundaries.mat
load ~/igdata/soam_noec.mat
hold on; plot(lonEC,latEC,'k-','linewidth',2); axis equal;
hold on; plot(lon_noec,lat_noec,'-','linewidth',2,'color',[0.5 0.5 0.5]); axis equal;
cbar = colorbar;
S3.MarkerEdgeColor = 'k';
S3.MarkerFaceAlpha = 0.8;
S3.MarkerEdgeAlpha = 0.9;
ax = gca; set(ax,'Colorscale','log'); clim([1 200]);
xlabel('long.'); ylabel('lat.');
cbar.Label.Interpreter = 'latex';
cbar.Label.String = 'depth [km.]';