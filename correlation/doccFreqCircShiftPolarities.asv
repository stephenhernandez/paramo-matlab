function [maxccp,plags,pol] = doccFreqCircShiftPolarities(data,...
    verboseFlag,refBlock,maxLag)

%
% Written by Stephen Hernandez
% Instituto Geofisico, Quito, Ecuador
% 20 May 2025, returns polarity flips if they exist
% Major edits December 2025
%

%%
if nargin < 2
    verboseFlag = false;
end

if nargin < 3
    refBlock = [];
end

%%
data = data./rssq(data);
[winlen,n] = size(data);
if nargin < 4
    maxLag = winlen-1;
end

%% n == 1
if n < 2
    if verboseFlag
        fprintf("single vector. returning dummies.\n");
    end
    maxccp = NaN(1);
    plags = maxccp;
    pol = maxccp;
    return;
end

%%
if verboseFlag
    fprintf("Window Length: %d\n",winlen);
    fprintf("Number of Events: %d\n",n);
end

%% get proper fft length
nfft = 2*winlen;
if mod(winlen,2)
    nfft = nfft + 2; %if odd, add 1, multiply by two (is now EVEN)
end

%%
data = fft(data,nfft);
nfft2 = nfft/2;
zeroIndex = nfft2+1;

%% get the job done
if ~isempty(refBlock)
    % user has defined refBlock
    % assume refblock and data block are mutually exclusive
    % check if refblock and data block have same duration
    [rb_r,rb_c] = size(refBlock);
    if rb_r ~= winlen
        fprintf(2,"major error. refblock and datablock have different durations");
        return;
    end

    [maxccp,plags,pol] = doccFreqCircShiftPolarities(refBlock,verboseFlag,[],maxLag); %<-- i am using recursion here
    refBlock = fft(refBlock,nfft);
    data = conj(data);
    [maxccp_ne,plags_ne,pol_ne] = docc_uneven(data,refBlock,zeroIndex,...
        maxLag,rb_c,n,verboseFlag);
    maxccp = [squareform(maxccp) maxccp_ne];
    plags = [squareform(plags) plags_ne];
    pol = [squareform(pol) pol_ne];
    return;
end

%%
if n == 2
    % user has not defined refBlock
    if verboseFlag
        fprintf("Number of Combos: 1\n");
    end
    refBlock = conj(data(:,2));
    data = data(:,1);
    [maxccp,plags,pol] = docc_(data,refBlock,zeroIndex,maxLag);
    return;
end

%% n is 3 or greater (n >= 3)
% user has not defined refBlock
refBlock = conj(data);
refBlock = circshift(refBlock,-1,2);
[maxccp,plags,pol] = docc_(data,refBlock,zeroIndex,maxLag);
[numShifts,ncol,excess,shuffleVec,flipVec] = shuffleVector(n);
if verboseFlag
    fprintf("Number of Combos: %d\n",ncol);
end
% maxccp = NaN(ncol,1);
% plags = maxccp;
% pol = maxccp;

if numShifts < 2
    % %% n == 3 (numShifts == 1)
    % [maxccp,plags,pol] = docc_(data,refBlock,zeroIndex,maxLag);

    %% adjust lag indices
    maxccp(shuffleVec) = maxccp;
    plags(shuffleVec) = plags;
    pol(shuffleVec) = pol;
    plags(flipVec) = -plags(flipVec);
    maxccp = maxccp';
    plags = plags';
    pol = pol';
    return;
end

%% made it this far, n > 3 (numShifts > 1)
ei = n*(1:numShifts)';
si = 1 + n*(0:numShifts-1)';
for i = 1:numShifts-1
    if verboseFlag
        fprintf("%d %d\n",i,numShifts);
    end
    ei_ = ei(i);
    si_ = si(i);
    [maxccp_,plags_,pol_] = docc_(data,refBlock,zeroIndex,maxLag);
    maxccp(si_:ei_) = maxccp_';
    plags(si_:ei_) = plags_';
    pol(si_:ei_) = pol_';
    refBlock = circshift(refBlock,-1,2); %ready for next iteration
end

%%
si_ = si(numShifts);
ei_ = ei(numShifts);
if excess
    ei_ = ei_ - excess;
    data = data(:,1:end-excess);
    refBlock = refBlock(:,1:end-excess);
end
[maxccp_,plags_,pol_] = docc_(data,refBlock,zeroIndex,maxLag);
maxccp(si_:ei_) = maxccp_';
plags(si_:ei_) = plags_';
pol(si_:ei_) = pol_';

%% adjust lag indices
maxccp(shuffleVec) = maxccp;
pol(shuffleVec) = pol;
plags(shuffleVec) = plags;
plags(flipVec) = -plags(flipVec);
end

%%
function [maxccp_ne,plags_ne,pol_ne] = docc_uneven(data,refBlock,zeroIndex,...
    maxLag,rb_c,d_c,verboseFlag)
TRANSPOSEFLAG = false;
N = rb_c;
maxccp_ne = zeros(rb_c,d_c);
if d_c < rb_c
    TRANSPOSEFLAG = true;
    N = d_c;
    refblock_orig = refBlock;
    refBlock = data;
    data = refblock_orig;
    maxccp_ne = maxccp_ne';
end
plags_ne = maxccp_ne;
pol_ne = maxccp_ne;

for i = 1:N
    if verboseFlag
        fprintf("%d\n",i);
    end
    refBlock_ = refBlock(:,i);
    %*i dont have to reshape rb because matlab does expansion implicitly*%
    [maxccp_ne_,plags_ne_,pol_ne_] = docc_(data,refBlock_,zeroIndex,maxLag);
    maxccp_ne(i,:) = maxccp_ne_;
    plags_ne(i,:) = plags_ne_;
    pol_ne(i,:) = pol_ne_;
end

if TRANSPOSEFLAG
    maxccp_ne = maxccp_ne';
    plags_ne = plags_ne';
    pol_ne = pol_ne';
end
end

%%
function [maxccp,plags,pol] = docc_(data,refBlock,zeroIndex,maxLag)
%
% [maxccp,plags,pol] are returned as row vectors
%
Ctmp = data.*refBlock;
Ctmp = fftshift(ifft(Ctmp,[],1,"symmetric"),1);

pol = sign(Ctmp);
Ctmp = abs(Ctmp);

si = zeroIndex - maxLag;
ei = zeroIndex + maxLag;
Ctmp = Ctmp(si:ei,:);
pol = pol(si:ei,:);

%% positive and negative cc coeffs. and lags
zeroIndex = maxLag+1;
[maxccp,plags] = max(Ctmp,[],1);
[~,plagsLinear] = max(Ctmp,[],1,"linear");
pol = pol(plagsLinear);
plags = plags - zeroIndex;
end