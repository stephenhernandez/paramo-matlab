function S = transfer(S,zero,pole,constant,lfc,hfc,npoles,deconvolve,verboseFlag,CANUSEGPU)
%
% code to apply _same_ poles/zeros to _all_ traces
% assumes the sampling rate is the same across all traces
%

%%
if nargin < 5; lfc = -inf; end
if nargin < 6; hfc = -inf; end
if nargin < 7; npoles = 4; end
if nargin < 8; deconvolve = 1; end
if nargin < 9; verboseFlag = false; end
if nargin < 10; CANUSEGPU = false; end

%%
npts = pull(S,"npts");
uniqnpts = unique(npts);
luniqnpts = length(uniqnpts);

for j = 1:luniqnpts
    uniqnpts_ = uniqnpts(j);
    nI = find(uniqnpts_ == npts);
    S_ = S(nI);
    nn = length(nI);
    
    %%
    Fs = 1/S_(1).delta;
    d = double(pull(S_));

    norig = length(d);
    
    %
    if verboseFlag
        fprintf("getting response information...\n");
    end
    
    %
    if deconvolve
        if verboseFlag
            fprintf("deconvolving instrument...\n");
        end
        newConstant = 1/constant;
        Hdecon = cmplxResp(norig,pole,zero,newConstant,Fs);
    else
        if verboseFlag
            fprintf("applying new instrument...\n");
        end
        Hdecon = cmplxResp(norig,zero,pole,constant,Fs);
    end
    

    %%
    if any(isfinite([lfc hfc]))
        if verboseFlag
            fprintf("applying filter: %f %f\n",lfc,hfc);
        end
        Hbu = freqOperator(norig,lfc,hfc,Fs,npoles);
        Hdecon = Hdecon.*Hbu;
    end
    
    
    D = fft(d);
    D = D.*Hdecon; % implicit expansion
    d = ifft(D,[],1,"symmetric");
    
    %%
    for i = 1:nn
        d_ = d(:,i);
        S_(i).d = d_;
        S_(i).npts = norig;
        S_(i).delta = 1/Fs;
        S_(i).e = seconds((S_(i).npts-1)*S_(i).delta);
        
        %%
        [minVals,maxVals,meanVals] = minmaxmean(d_);
        S_(i).depmin = minVals;
        S_(i).depmax = maxVals;
        S_(i).depmen = meanVals;
    end
    S(nI) = S_;
end
